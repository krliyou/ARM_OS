; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave --gnu -o.\obj\sem.o --asm_dir=.\OBJ\ --list_dir=.\OBJ\ --depend=.\obj\sem.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I..\..\..\..\kernel -I.\app -I.\drivers\UART -I.\board -I.\board\Exception\Systick -I.\board\Interrupt -I.\board\System_Init -I.\board\Exception\ErrorHandler -I.\board\Register -I..\..\..\..\lib\include -I.\board\Delay -I..\..\..\..\components\shell -I..\..\..\..\lib\include -I..\..\..\..\lib\list -I..\..\..\..\lib\ringbuffer -I.\drivers\LED -I..\..\..\..\board\arm\cortex-m3 -I..\..\..\..\..\ARM_OS -I.\RTE\_liyou -ID:\36Keil_5_MDK\install\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\36Keil_5_MDK\install\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=527 -DSTM32F10X_HD -DSTM32F10X_HD --omf_browse=.\obj\sem.crf ..\..\..\..\kernel\sem.c]
                          THUMB

                          AREA ||i._rt_sem_take||, CODE, READONLY, ALIGN=2

                  _rt_sem_take PROC
;;;43     
;;;44     static signed long _rt_sem_take(struct ly_semaphore *sem, unsigned int timeout, int suspend_flag)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;45     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;46         signed long level;
;;;47         struct ly_task *thread;
;;;48         signed long ret;
;;;49     	
;;;50         level = interrupt_disable();
00000a  f7fffffe          BL       interrupt_disable
00000e  4681              MOV      r9,r0
;;;51     
;;;52         if (sem->value > 0)
000010  8920              LDRH     r0,[r4,#8]
000012  2800              CMP      r0,#0
000014  dd06              BLE      |L1.36|
;;;53         {
;;;54             sem->value --;
000016  8920              LDRH     r0,[r4,#8]
000018  1e40              SUBS     r0,r0,#1
00001a  8120              STRH     r0,[r4,#8]
;;;55             interrupt_enable(level);
00001c  4648              MOV      r0,r9
00001e  f7fffffe          BL       interrupt_enable
000022  e037              B        |L1.148|
                  |L1.36|
;;;56         }
;;;57         else
;;;58         {
;;;59     		if (timeout == 0)
000024  b936              CBNZ     r6,|L1.52|
;;;60             {
;;;61                 interrupt_enable(level);
000026  4648              MOV      r0,r9
000028  f7fffffe          BL       interrupt_enable
;;;62                 return -LY_ETIMEOUT;
00002c  f06f0001          MVN      r0,#1
                  |L1.48|
;;;63             }
;;;64             else
;;;65             {
;;;66     			thread = get_current_task();
;;;67                 thread->error = -LY_EINTR;
;;;68     			if ((thread->stat & LY_THREAD_SUSPEND) != LY_THREAD_SUSPEND)
;;;69     			{
;;;70     				signed long ret = ly_task_suspend_with_flag(thread, suspend_flag);
;;;71     				list_add_before(&(thread->tlist), &(sem->suspend_thread));
;;;72     			}
;;;73     
;;;74                 if (ret != LY_EOK)
;;;75                 {
;;;76                     interrupt_enable(level);
;;;77                     return ret;
;;;78                 }
;;;79     
;;;80                 if (timeout > 0)
;;;81                 {		
;;;82     				thread->task_timer.init_tick = timeout;
;;;83     
;;;84                     ly_timer_start(&(thread->task_timer));
;;;85                 }
;;;86     
;;;87     			interrupt_enable(level);
;;;88     
;;;89                 ly_schedule();
;;;90     
;;;91                 if (thread->error != LY_EOK)
;;;92                 {
;;;93                     return thread->error;
;;;94                 }
;;;95             }
;;;96         }
;;;97     
;;;98         return 0;
;;;99     }
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L1.52|
000034  4818              LDR      r0,|L1.152|
000036  6805              LDR      r5,[r0,#0]            ;66  ; ly_current_thread
000038  f06f0008          MVN      r0,#8                 ;67
00003c  6228              STR      r0,[r5,#0x20]         ;67
00003e  7d28              LDRB     r0,[r5,#0x14]         ;68
000040  f0000004          AND      r0,r0,#4              ;68
000044  2804              CMP      r0,#4                 ;68
000046  d00e              BEQ      |L1.102|
000048  4639              MOV      r1,r7                 ;70
00004a  4628              MOV      r0,r5                 ;70
00004c  f7fffffe          BL       ly_task_suspend_with_flag
000050  4682              MOV      r10,r0                ;70
000052  f1050044          ADD      r0,r5,#0x44           ;71
000056  6861              LDR      r1,[r4,#4]            ;71
000058  6060              STR      r0,[r4,#4]            ;71
00005a  6004              STR      r4,[r0,#0]            ;71
00005c  6041              STR      r1,[r0,#4]            ;71
00005e  6008              STR      r0,[r1,#0]            ;71
000060  bf00              NOP                            ;71
000062  bf00              NOP                            ;71
000064  bf00              NOP                            ;72
                  |L1.102|
000066  f1b80f00          CMP      r8,#0                 ;74
00006a  d004              BEQ      |L1.118|
00006c  4648              MOV      r0,r9                 ;76
00006e  f7fffffe          BL       interrupt_enable
000072  4640              MOV      r0,r8                 ;77
000074  e7dc              B        |L1.48|
                  |L1.118|
000076  b126              CBZ      r6,|L1.130|
000078  63ae              STR      r6,[r5,#0x38]         ;82
00007a  f1050028          ADD      r0,r5,#0x28           ;84
00007e  f7fffffe          BL       ly_timer_start
                  |L1.130|
000082  4648              MOV      r0,r9                 ;87
000084  f7fffffe          BL       interrupt_enable
000088  f7fffffe          BL       ly_schedule
00008c  6a28              LDR      r0,[r5,#0x20]         ;91
00008e  b108              CBZ      r0,|L1.148|
000090  6a28              LDR      r0,[r5,#0x20]         ;93
000092  e7cd              B        |L1.48|
                  |L1.148|
000094  2000              MOVS     r0,#0                 ;98
000096  e7cb              B        |L1.48|
;;;100    
                          ENDP

                  |L1.152|
                          DCD      ly_current_thread

                          AREA ||i.list_empty||, CODE, READONLY, ALIGN=1

                  list_empty PROC
;;;41     
;;;42     static inline int list_empty(const struct list_head *head)
000000  4601              MOV      r1,r0
;;;43     {
;;;44     	return head->next == head;
000002  6808              LDR      r0,[r1,#0]
000004  4288              CMP      r0,r1
000006  d101              BNE      |L2.12|
000008  2001              MOVS     r0,#1
                  |L2.10|
;;;45     }
00000a  4770              BX       lr
                  |L2.12|
00000c  2000              MOVS     r0,#0                 ;44
00000e  e7fc              B        |L2.10|
;;;46     
                          ENDP


                          AREA ||i.ly_sem_detach||, CODE, READONLY, ALIGN=1

                  ly_sem_detach PROC
;;;25     
;;;26     signed long ly_sem_detach(struct ly_semaphore *sem)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;27     {
000004  4605              MOV      r5,r0
;;;28     	struct ly_task *thread;
;;;29         unsigned int level;
;;;30     	struct list_head *suspend = &(sem->suspend_thread);
000006  462e              MOV      r6,r5
;;;31     
;;;32         while (!list_empty(suspend))
000008  e00f              B        |L3.42|
                  |L3.10|
;;;33         {
;;;34     		level = interrupt_disable();
00000a  f7fffffe          BL       interrupt_disable
00000e  4607              MOV      r7,r0
;;;35             thread = list_entry(suspend->next, struct ly_task, tlist);
000010  6831              LDR      r1,[r6,#0]
000012  f1a10044          SUB      r0,r1,#0x44
000016  4604              MOV      r4,r0
;;;36             thread->error = -LY_ERROR;
000018  f04f30ff          MOV      r0,#0xffffffff
00001c  6220              STR      r0,[r4,#0x20]
;;;37             ly_task_resume(thread);
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       ly_task_resume
;;;38     		interrupt_enable(level);
000024  4638              MOV      r0,r7
000026  f7fffffe          BL       interrupt_enable
                  |L3.42|
00002a  4630              MOV      r0,r6                 ;32
00002c  f7fffffe          BL       list_empty
000030  2800              CMP      r0,#0                 ;32
000032  d0ea              BEQ      |L3.10|
;;;39         }
;;;40     
;;;41         return 0;
000034  2000              MOVS     r0,#0
;;;42     }
000036  e8bd81f0          POP      {r4-r8,pc}
;;;43     
                          ENDP


                          AREA ||i.ly_sem_init||, CODE, READONLY, ALIGN=1

                  ly_sem_init PROC
;;;13     
;;;14     signed long ly_sem_init(struct ly_semaphore *sem, 
000000  b510              PUSH     {r4,lr}
;;;15     					const char *name, unsigned int value, unsigned char flag)
;;;16     {
000002  4604              MOV      r4,r0
;;;17     	sem->value = (unsigned int)value;
000004  8122              STRH     r2,[r4,#8]
;;;18     
;;;19     	sem->flag = flag;
000006  7323              STRB     r3,[r4,#0xc]
;;;20     
;;;21     	list_init(&(sem->suspend_thread));
000008  bf00              NOP      
00000a  6024              STR      r4,[r4,#0]
00000c  6064              STR      r4,[r4,#4]
00000e  bf00              NOP      
;;;22     
;;;23         return 0;
000010  2000              MOVS     r0,#0
;;;24     }
000012  bd10              POP      {r4,pc}
;;;25     
                          ENDP


                          AREA ||i.ly_sem_release||, CODE, READONLY, ALIGN=1

                  ly_sem_release PROC
;;;105    
;;;106    signed long ly_sem_release(struct ly_semaphore *sem)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;107    {
000004  4604              MOV      r4,r0
;;;108        signed long level;    
;;;109    	int need_schedule;
;;;110    	struct ly_task *thread;
;;;111    
;;;112        need_schedule = LY_FALSE;
000006  2600              MOVS     r6,#0
;;;113    
;;;114        level = interrupt_disable();
000008  f7fffffe          BL       interrupt_disable
00000c  4607              MOV      r7,r0
;;;115    
;;;116        if (!list_empty(&sem->suspend_thread))
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       list_empty
000014  b950              CBNZ     r0,|L5.44|
;;;117        {
;;;118    		thread = list_entry(sem->suspend_thread.next, struct ly_task, tlist);
000016  6821              LDR      r1,[r4,#0]
000018  f1a10044          SUB      r0,r1,#0x44
00001c  4605              MOV      r5,r0
;;;119    
;;;120    		thread->error = LY_EOK;
00001e  2000              MOVS     r0,#0
000020  6228              STR      r0,[r5,#0x20]
;;;121    
;;;122    		ly_task_resume(thread);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       ly_task_resume
;;;123            need_schedule = LY_TRUE;
000028  2601              MOVS     r6,#1
00002a  e00f              B        |L5.76|
                  |L5.44|
;;;124        }
;;;125        else
;;;126        {
;;;127            if(sem->value < LY_SEM_VALUE_MAX)
00002c  8920              LDRH     r0,[r4,#8]
00002e  f64f71ff          MOV      r1,#0xffff
000032  4288              CMP      r0,r1
000034  d203              BCS      |L5.62|
;;;128            {
;;;129                sem->value ++;
000036  8920              LDRH     r0,[r4,#8]
000038  1c40              ADDS     r0,r0,#1
00003a  8120              STRH     r0,[r4,#8]
00003c  e006              B        |L5.76|
                  |L5.62|
;;;130            }
;;;131            else
;;;132            {
;;;133                interrupt_enable(level); 	
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       interrupt_enable
;;;134                return -LY_EFULL; 	
000044  f06f0002          MVN      r0,#2
                  |L5.72|
;;;135            }
;;;136        }
;;;137    	
;;;138    	interrupt_enable(level);
;;;139    
;;;140        if (need_schedule == LY_TRUE)
;;;141            ly_schedule();
;;;142    
;;;143        return LY_EOK;
;;;144    }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L5.76|
00004c  4638              MOV      r0,r7                 ;138
00004e  f7fffffe          BL       interrupt_enable
000052  2e01              CMP      r6,#1                 ;140
000054  d101              BNE      |L5.90|
000056  f7fffffe          BL       ly_schedule
                  |L5.90|
00005a  2000              MOVS     r0,#0                 ;143
00005c  e7f4              B        |L5.72|
;;;145    
                          ENDP


                          AREA ||i.ly_sem_take||, CODE, READONLY, ALIGN=1

                  ly_sem_take PROC
;;;100    
;;;101    signed long ly_sem_take(struct ly_semaphore *sem, unsigned int time)
000000  b570              PUSH     {r4-r6,lr}
;;;102    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;103        return _rt_sem_take(sem, time, LY_UNINTERRUPTIBLE);
000006  2202              MOVS     r2,#2
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       _rt_sem_take
;;;104    }
000010  bd70              POP      {r4-r6,pc}
;;;105    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  ly_sem
                          %        16

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\..\\kernel\\sem.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_sem_c_ly_sem____REV16|
#line 464 ".\\board\\Interrupt\\Nvic_armcc.h"
|__asm___5_sem_c_ly_sem____REV16| PROC
#line 465

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_sem_c_ly_sem____REVSH|
#line 479
|__asm___5_sem_c_ly_sem____REVSH| PROC
#line 480

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_sem_c_ly_sem____RRX|
#line 666
|__asm___5_sem_c_ly_sem____RRX| PROC
#line 667

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
